# 实现原理解释（Windows/Winsock 版）

## 通信模型
- 采用 TCP（面向连接、可靠字节流）。
- 服务器监听端口等待连接，客户端主动发起连接；三次握手完成后通过套接字描述符进行 `send/recv` 全双工通信。

## 服务器端（见 [server.c](server.c)）
- **初始化/释放**：`WSAStartup` 初始化 Winsock，程序结束 `WSACleanup` 释放资源。
- **创建与复用**：`socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)` 创建 TCP 套接字；`SO_REUSEADDR` 允许端口复用便于频繁重启。
- **绑定/监听**：设置 `sockaddr_in` 为 `INADDR_ANY:9000`，调用 `bind()`、`listen()` 建立监听队列。
- **接受连接与收发**：
	- `accept()` 返回客户端专用 `SOCKET`；用 `InetNtopA` 将对端地址打印出来。
	- 循环 `recv()` 读取客户端数据，随后 `send()` 原样回显（echo）。
- **关闭**：收发结束或出错后 `closesocket(conn_fd)`；最终关闭监听套接字并 `WSACleanup()`。

## 客户端（见 [client.c](client.c)）
- **初始化**：`WSAStartup`；创建 TCP 套接字。
- **地址与连接**：`inet_pton()` 将字符串 IP 转网络序；`connect()` 主动连到 `SERVER_IP:SERVER_PORT`。
- **交互循环**：`fgets()` 从标准输入取一行，`send()` 发送；`recv()` 等回显并打印。Ctrl+Z 结束输入退出。
- **清理**：通信结束后 `closesocket()`，再 `WSACleanup()` 释放。

## 数据收发路径（echo 流程）
1. 客户端从标准输入读一行，`send()` 写入 TCP 连接。
2. TCP 可靠传输到服务器；服务器 `recv()` 读出。
3. 服务器打印后 `send()` 回显同样的字节流。
4. 客户端 `recv()` 获取回显，显示在终端。

## 异常与退出行为
- `recv()` 返回 0：对端优雅关闭，服务器随后关闭该连接。
- `recv()/send()` 出错：检查返回值与 `WSAGetLastError()`，打印后关闭连接。
- 程序退出：确保已 `closesocket()`，最终 `WSACleanup()`。

## 可扩展方向
- **并发**：每连接一个线程，或改用 IOCP/多路复用以支撑高并发。
- **协议**：添加长度字段/消息头防止粘包，加入心跳、超时与重试。
- **安全**：集成 TLS（SChannel/OpenSSL），增加鉴权与输入校验。
- **健壮性**：配置化 IP/端口/缓冲区，增加日志分级与超时设置。
